# 性能优化专题 TODO

## 目标与验收
- [ ] 目标场景：列表 10,000 条 + 文章 100,000 字 + OPPO Watch X2。
- [ ] 目标指标：关键滚动场景 60fps（单帧耗时 <= 16.6ms），连续卡顿 <= 1%，Jank <= 5%。
- [ ] 基线对比：每次优化前后输出相同场景的帧率与掉帧统计，形成对比表。

## Step 1 - 性能测量与回放场景
- [ ] 新增可复现的“超大列表/超大文章”调试入口（DebugOnly），确保一键进入目标场景。
- [ ] 接入 JankStats/FrameMetrics，记录滚动时的帧耗时与掉帧比。
- [ ] 增加 Macrobenchmark（或本地脚本）用于批量复测，固定输入与滚动路径。

## Step 2 - 内容解析与缓存下沉
- [ ] 将摘要格式化与首图提取从主线程迁移到后台（IO/Default），并缓存结果。
- [ ] 为 RSS 列表项新增“摘要/首图”持久化字段或内存缓存，避免滚动时重复解析。
- [ ] 对 HTML 解析加结果缓存与去重（同一内容只解析一次）。

## Step 3 - 列表渲染链路优化
- [ ] LazyColumn 结构改为“header item + items(items)”分段，避免每次构建完整 entryList。
- [ ] 列表项中所有重计算逻辑使用 `remember`/`derivedStateOf`，避免非必要重组。
- [ ] 统一图片加载尺寸与解码策略（按手表分辨率下采样），减少大图解码成本。
- [ ] 评估并限制列表项的复杂布局（如 IntrinsicSize），在必要处改为固定/约束尺寸。

## Step 4 - 详情页超长正文优化
- [ ] 将详情页由 Column + verticalScroll 改为 LazyColumn，内容块按需渲染。
- [ ] 超长文本块拆分为小段（段落/固定长度），减少单次布局成本。
- [ ] 内容块列表缓存与复用：同一文章重复进入不重复解析。

## Step 5 - 数据层与分页
- [ ] 列表数据改为分页加载（Paging3 或手动分页），避免一次性加载 10k 条到内存。
- [ ] DB 查询加入分页与排序索引，减少主线程等待与内存峰值。

## Step 6 - 回归验证与门禁
- [ ] 每次优化提交必须附带：指标对比 + 关键场景录屏/截图。
- [ ] 建立性能回归基线（脚本/benchmark），不达 60fps 不允许合并。
